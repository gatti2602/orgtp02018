\documentclass[10pt,a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage[spanish]{babel}
\usepackage[left=2cm,top=4cm,right=2cm,bottom=3cm]{geometry} 
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{dcolumn}
\usepackage{float}
\usepackage{graphicx}
\usepackage{ esint }
\usepackage{fancyhdr}
\usepackage{enumerate} 
\pagestyle{fancy}
\usepackage{tocbibind}
\usepackage{setspace}
\usepackage{parskip}
\usepackage[hidelinks]{hyperref}
\usepackage{listings} 
\usepackage[svgnames]{xcolor}


\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstset{basicstyle=\ttfamily}
\lstdefinestyle{mystyle}{
	%backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	breakatwhitespace=false,         
	breaklines=true,                 
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt                  
}
\lstset{literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}

\lstset{showstringspaces=false}
\lstloadlanguages{C++}
\lstset{basicstyle=\ttfamily\footnotesize}
\lstset{style=mystyle}
\usepackage[titletoc,toc,page]{appendix}
\usepackage{pdfpages}
\renewcommand{\appendixtocname}{Anexo}
\renewcommand{\appendixpagename}{Anexo}
\lhead{ Organización de computadoras - TP0 }
\rhead{\includegraphics[width=1.5 cm]{logo}}
\author{cyn}
\begin{document}
\begin{titlepage}
\begin{center}
\vspace*{-1in}
\begin{figure}[htb]
\begin{flushleft}
\includegraphics[width=5cm]{./logo}
\end{flushleft}
\end{figure}
\begin{LARGE}
\textbf{U.B.A. FACULTAD DE INGENIERÍA}\\
\end{LARGE}
\vspace*{0.15in}
\begin{LARGE}
\textbf{Departamento de Electrónica}\\
\end{LARGE}
\vspace*{0.2in}
\begin{LARGE}
\textbf{Organización de computadoras 66-20}\\
\end{LARGE}
\vspace*{0.2in}
\begin{Large}
\textbf{TRABAJO PRÁCTICO \#0}\\
\end{Large}
\vspace*{0.2in}
\begin{LARGE}
\textit{Infraestructura básica }\\
\end{LARGE}
\vspace*{0.2in}
\begin{Large}
\raggedright\textbf{Curso: 2018 - 2do Cuatrimestre}\\
\end{Large}
\vspace*{0.1in}
\begin{Large}
\raggedright\textbf{Turno: Martes}\\
\end{Large}
\vspace*{0.1in}

\begin{table}[htb]
\begin{center}
\begin{spacing}{1.9}
\begin{tabular}{| l | l |}
\hline
\multicolumn{2}{|>{\arraybackslash}p{15cm}|}{\begin{Large}
\textbf{GRUPO N°}
\end{Large}}\\
\hline
\textbf{Integrantes} & \textbf{Padrón} \\
\hline
\makebox[8cm][c]{Verón, Lucas} & \makebox[2.5cm][c]{89341}\\
\hline
\makebox[8cm][c]{Gamarra Silva, Cynthia Marlene} & \makebox[2.5cm][c]{92702}\\
\hline
\makebox[8cm][c]{Gatti, Nicolás} & \makebox[2.5cm][c]{93570}\\
\hline
\textbf{Fecha de entrega: } & \hspace{0.8cm}18-09-2018\\
\hline
\textbf{Fecha de aprobación: } & \\
\hline
\textbf{Calificación: } & \\
\hline
\textbf{Firma de aprobación:} & \\
\hline
\end{tabular}
\end{spacing}
\end{center}
\end{table}
\fbox{%
\begin{minipage}[c][3.4cm][l]{.9\linewidth}
\textbf{Observaciones:} \\
\vfill
\end{minipage}
}
\end{center}

\vspace*{0.1in}
\end{titlepage}
\tableofcontents 
\vspace*{0.3in}
\newpage

\includepdf[pages=1,scale=0.95,pagecommand = \section{Enunciado del trabajo práctico}\label{enunciado},offset=10 -10]{../tp0-2018-2q.pdf}
\includepdf[pages={2-last},scale=0.95,pagecommand = {},offset=10 -10]{../tp0-2018-2q.pdf}


\newpage

\subsection{Diseño e implementación}

El programa que contiene la lógica de codificador y decodificador se encuentra en el archivo \textit{\textbf{encode.c}}.
El codificador transforma expresiones con caracteres ASCII en base64, mientras que el decodificador hace el proceso inverso.
Ambas funciones se implementan con diversos ciclos y recorridos, así como utilización de instrucciones aritmético lógicas (sumas, \&, shifts, etc) que relacionan la codificación base 64 con ASCII.

Se creó un achivo \textit{\textbf{file.c}} para el manejo de los archivos a codificar/decodificar. Además se creó otro archivo llamado \textit{\textbf{command.c}} cuya función es tomar los parámetros del programa y realizar las acciones pertinentes a la misma. 

Específicamente el programa se estructura en los siguientes pasos:
\begin{itemize}
	\item \underline{Análisis de las parámetros de la línea de comandos}: se analizan las opciones ingresadas por la línea de comandos utilizando la función \texttt{getopt\_long()}, la cual puede procesar cada opción que es leída de forma simplificada. Se extraen los argumentos de cada opción y se los guarda dentro de una estructura para su posterior acceso del tipo \texttt{CommandOptions} cuya definición es
	\begin{lstlisting}[language=C]
	typedef struct {
    		File input;
    		File output;
    		const char* input_route;
    		const char* output_route;
    		char error;
    		char encode_opt;
	} CommandOptions;
	\end{lstlisting}
En caso de que no se encuentre alguna opción, se muestra el mensaje de ayuda al usuario para que identifique el prototipo de cómo debe ejecutar el programa.
	
	\item \underline{Validación de opciones:} a medida que se va analizando cada opción de la línea de comandos, se valida cada una de ellas. Si se ingresó algún parámetro no válido para el programa o si se encuentró un error se lo informa al usuario por pantalla y se aborta la ejecución del programa. Se utiliza para ello se la función \texttt{CommandErrArg()} cuyo resultado es:
	\begin{lstlisting}[language=C]
		fprintf(stderr, "Invalid Arguments\n");
    		fprintf(stderr,"Options:\n");
    		fprintf(stderr,"  -V, --version    Print version and quit.\n");
    		fprintf(stderr,"  -h, --help       Print this information.\n");
    		fprintf(stderr,"  -i, --input      Location of the input file.\n");
    		fprintf(stderr,"  -o, --output     Location of the output file.\n");
    		fprintf(stderr,"  -a, --action     Program action: encode (default) or decode.\n");
    		fprintf(stderr,"Examples:\n");
    		fprintf(stderr,"  tp0 -a encode -i ~/input -o ~/output\n");
    		fprintf(stderr,"  tp0 -a decode\n");
	\end{lstlisting}

	Para el caso en que no hubo errores a la validación de los argumentos se procede a llamar a las funciones correspondientes a:
	\begin{itemize}
		\item \texttt{Mensaje de ayuda: } Función \texttt{CommandVersion()}
		\item \texttt{Mensaje de versión: } Función \texttt{CommandHelp()}
		\item \texttt{Input file : } Función \texttt{CommandSetInput()} que guarda la entrada del archivo donde será leído el texto. 
		\item \texttt{Output file: } Función {CommandSetOutput()} que guarda la entrada del archivo de salida donde se escribirá el texto codificado.
		\item \texttt{Acción del programa a ejecutar: } Función {CommandSetEncodeOpt()} que setea la variable $opt->encode\_opt$ indicando si es una operación de ENCODE o DECODE respectivamente.
\end{itemize}

	\item \underline{Encode/Decode:} una vez que se procesó correctamente las opciones de la línea de comandos se procede a llamar a la función \texttt{\_CommandEncodeDecode()} que ejecutará la operación de ENCODE o DECODE dependiendo del argumento pasado en la línea de comandos. 
La operación de DECODE se ejecuta el siguiente código:
\begin{lstlisting}[language=C]
while (!FileEofReached(&opt->input) && !CommandHasError(opt)) {
            unsigned int read = FileRead(&opt->input, buf_encoded, 4);
            if (read > 0) {   // Solo es 0 si alcance el EOF
                if (read != 4) {  //Siempre debo leer 4 sino el formato es incorrecto
                    fprintf(stderr, "Longitud de archivo no es multiplo de 4\n");
                    CommandSetError(opt);
                } else {
                    ++count;
                    if (count == 18) { // 19 * 4 = 76 bytes
                        unsigned char aux;
                        FileRead(&opt->input, &aux, 1);
                        count = 0;
                    }
                    if (Decode(buf_encoded, buf_decoded)) {
                        char aux = 0;
                        if (buf_encoded[2] == '=')
                            ++aux;
                        if (buf_encoded[3] == '=')
                            ++aux;

                        FileWrite(&opt->output, buf_decoded, 3 - aux);
                    } else {
                        fprintf(stderr, "Caracteres invalidos en archivo codificado: ");
                        unsigned int i;
                        for (i = 0; i < 4; ++i)
                            fprintf(stderr, "%c", buf_encoded[i]);
                        CommandSetError(opt);
                    }
                }
            }


        }
	\end{lstlisting}
	Básicamente lo que se realiza es la lectura del archivo para procesarlo teniendo en cuenta la longitud del archivo a procesar y el padding a decodificar. La función \texttt{Decode()} retorna un buffer de 3 caracteres con el decode de 4 caracteres en base64. Se debe cumplir:\\

 * Pre: el buffer input contiene 4 caracteres. El buffer output tiene por lo menos 3 caracteres
 * Post: retorna un buffer de 3 byte con los caracteres en ASCII. retorna 0 si error 1 si ok.


La operación de ENCODE se ejecuta el siguiente código:
\begin{lstlisting}[language=C]
        while(!FileEofReached(&opt->input)){
            memset(buf_decoded, 0, 3);
            unsigned int read = FileRead(&opt->input, buf_decoded, 3);
            if (read > 0) {
                Encode(buf_decoded, read, buf_encoded);
                FileWrite(&opt->output, buf_encoded, 4);
                ++count;
                if (count == 18) { // 19 * 4 = 76 bytes
                    FileWrite(&opt->output, (unsigned char *) "\n", 1);
                    count = 0;
                }

            }
        }
\end{lstlisting}
Básicamente lo que se realiza es la lectura del archivo para procesarlo en la función \texttt{Encode()}e n donde recibe 3 caracteres en buffer y los convierte en 4 caracteres codificados en output. Se debe cumplir:\\

 * Pre: el buffer contiene length caracteres (1 a 3) y todos los caracteres son validos
 * Post: retorna un buffer de 4 byte con los caracteres en base64.


	\end{itemize}


\subsection{Parámetros del programa}

Se detallan a continuación los parámetros del programa

\begin{itemize}
    \item -h: Visualiza la ayuda del programa, en la que se indican los parámetros y sus objetivos.
    \item -V: Indica la versión del programa.
    \item -i: Archivo de entrada del programa.
    \item -o: Archivo de salida del programa.
    \item -a: Acción a llevar a cabo: codificación o decodificación.
\end{itemize}

Se indica a continuación detalles respecto a los parámetros:

\begin{itemize}
    \item Si no se explicitan -i y -o, se utilizarán stdin y stdout, respectivamente. 
    \item -V es una opción ``show and quit". Si se explicita este parámetro, sólo se imprimirá la versión, aunque el resto de los parámetros se hayan explicitado. 
    \item -h también es de tipo ``show and quit " y se comporta de forma similar a -V.
    \item en caso de que se use la entrada estándar (con comando echo texto $|$ ./tp0 -a encode) y luego se especifique un archivo de salida con -i, prevalecerá el establecido por parámetro.
\end{itemize}

\subsection{Compilación del programa}

Para obtener un ejecutable, se creó un archivo \texttt{makefile} cuyo contenido es:
	\begin{lstlisting}[language=C]
CC = gcc
CFLAGS = -o0 -g -Wall -Werror -pedantic -std=c99

OBJECTS = command.o encode.o file.c
EXEC = tp0

VALGRIND = valgrind --track-origins=yes --leak-check=full
VALGRIND-V = $(VALGRIND) -v

all: $(EXEC)

command.o: command.c command.h
	$(CC) $(CFLAGS) -c command.c -o command.o
encode.o: encode.c encode.h
	$(CC) $(CFLAGS) -c encode.c -o encode.o
file.o: file.c file.h
	$(CC) $(CFLAGS) -c file.c -o file.o

$(EXEC): $(OBJECTS)
	$(CC) $(CFLAGS) $(OBJECTS) main.c -o $(EXEC) -lm

run: $(EXEC)
	./$(EXEC)

valgrind: $(EXEC)
	$(VALGRIND) ./$(EXEC)

valgrind-verb: $(EXEC)
	$(VALGRIND-V) ./$(EXEC)

clean:
	rm -f *.o $(EXEC)
	\end{lstlisting}


Para ejecutarlo, posicionarse en el directorio \texttt{src/} y ejecutar el siguiente comando:
\begin{lstlisting}
$ make
\end{lstlisting}

Para proceder a la ejecución del programa, se debe llamar a:

\begin{lstlisting}
$ ./tp0
\end{lstlisting}

seguido de los parámetros que se desee modificar, los cuales se indicaron en la sección 1.2.

En caso de ser entrada estándar (stdin) se podrá ejecutar de la siguiente forma:

\begin{lstlisting}
$ echo texto | ./tp0 -a encode
\end{lstlisting}

También en este caso, se indican a continuación los parámetros a usar.

Para el caso de hacerlo en el emulador GXemul que provee la cátedra, utilizando la máquina virtual que contiene el sistema operativo NetBSD, no se utilizó el archivo Makefile, la compilación se realizó con la herramienta \texttt{gcc}.
\newpage


\section{Pruebas realizadas}

\subsection{Pruebas con archivo bash test.sh}
Se realizan corridas de prueba con el siguiente script

\begin{lstlisting}
    #!/bin/bash

    n=1
    while :; do
            head -c $n </dev/urandom >/tmp/in.bin;
            ./tp0 -a encode -i /tmp/in.bin -o /tmp/out.b64;
            ./tp0 -a decode -i /tmp/out.bin -o /tmp/out.bin;
            if diff /tmp/in.bin /tmp/out.bin; then :; else
                    echo ERROR: $n;
                    break;
            fi
            echo ok: $n;
            n="`expr $n + 1`";
            rm -f /tmp/in.bin /tmp/out.b64 /tmp/out.bin o;
    done

\end{lstlisting}

El cual no presenta errores en ninguna de las corridas llevadas a cabo.


Todas las pruebas que se presentan a continuación, están codificadas en los archivos de prueba ***.txt de forma que puedan ejecutarse y comprobar los resultados obtenidos.

Se indicaran a continuación lo siguiente: comandos para ejecutarlas, líneas de código que las componen y resultado esperado.


\subsubsection{Generales}


\begin{itemize}
    \item Mensaje de ayuda\\
    
\begin{lstlisting}
$ ./tp0 -h  o ./tp0 --help

Options:
  -V, --version    Print version and quit.
  -h, --help       Print this information.
  -i, --input      Location of the input file.
  -o, --output     Location of the output file.
  -a, --action     Program action: encode (default) or decode.
Examples:
  tp0 -a encode -i ~/input -o ~/output
  tp0 -a decode


\end{lstlisting}     
     
	\item Mensaje de version\\

            \begin{lstlisting}
$ ./tp0 -V  o ./tp0 --version
Version: 0.1
             \end{lstlisting}  
         
         
    \item Archivo de entrada no válido
            \begin{lstlisting}
$ ./tp0 -i archivoInvalido.txt

Invalid Arguments
Options:
  -V, --version    Print version and quit.
  -h, --help       Print this information.
  -i, --input      Location of the input file.
  -o, --output     Location of the output file.
  -a, --action     Program action: encode (default) or decode.
Examples:
  tp0 -a encode -i ~/input -o ~/output
  tp0 -a decode


             \end{lstlisting}  

\end{itemize}


\newpage


\begin{thebibliography}{10}
	\bibitem{}Base64 (Wikipedia) http://en.wikipedia.org/wiki/Base64
	\bibitem{}The NetBSD project, http://www.netbsd.org/
	\bibitem{book_Cprogr} Kernighan, B. W. - Ritchie, D. M. - \emph{C Programming Language} - 2\textsuperscript{nd} edition - Prentice Hall - 1988.
	\bibitem{gnu_make} \emph{GNU Make} - \hyperlink{make}{https://www.gnu.org/software/make/}
	\bibitem{valgrind} \emph{Valgrind} - \hyperlink{valgrind}{http://valgrind.org/}

\end{thebibliography}
\newpage
%-----------------------------------%
%									%
%			Seccion:Fuente			%
%									%
%-----------------------------------%
\appendix
\section{Código fuente}\label{appendix_codigo_fuente}

\subsubsection{main.c}\label{main}
\lstinputlisting[language=C]{../src/main.c}

\newpage

\subsubsection{Assembly}\label{main.s}
\lstinputlisting[language=C]{../assembly/main.s}


\end{document}
